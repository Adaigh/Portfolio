import "./chunk-5WRI5ZAA.js";

// node_modules/heap-js/dist/heap-js.es5.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read$1 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray$1 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var HeapAsync = (
  /** @class */
  function() {
    function HeapAsync2(compare) {
      if (compare === void 0) {
        compare = HeapAsync2.minComparator;
      }
      var _this = this;
      this.compare = compare;
      this.heapArray = [];
      this._limit = 0;
      this.offer = this.add;
      this.element = this.peek;
      this.poll = this.pop;
      this._invertedCompare = function(a, b) {
        return _this.compare(a, b).then(function(res) {
          return -1 * res;
        });
      };
    }
    HeapAsync2.getChildrenIndexOf = function(idx) {
      return [idx * 2 + 1, idx * 2 + 2];
    };
    HeapAsync2.getParentIndexOf = function(idx) {
      if (idx <= 0) {
        return -1;
      }
      var whichChildren = idx % 2 ? 1 : 2;
      return Math.floor((idx - whichChildren) / 2);
    };
    HeapAsync2.getSiblingIndexOf = function(idx) {
      if (idx <= 0) {
        return -1;
      }
      var whichChildren = idx % 2 ? 1 : -1;
      return idx + whichChildren;
    };
    HeapAsync2.minComparator = function(a, b) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          if (a > b) {
            return [2, 1];
          } else if (a < b) {
            return [2, -1];
          } else {
            return [2, 0];
          }
        });
      });
    };
    HeapAsync2.maxComparator = function(a, b) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          if (b > a) {
            return [2, 1];
          } else if (b < a) {
            return [2, -1];
          } else {
            return [2, 0];
          }
        });
      });
    };
    HeapAsync2.minComparatorNumber = function(a, b) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          return [2, a - b];
        });
      });
    };
    HeapAsync2.maxComparatorNumber = function(a, b) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          return [2, b - a];
        });
      });
    };
    HeapAsync2.defaultIsEqual = function(a, b) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          return [2, a === b];
        });
      });
    };
    HeapAsync2.print = function(heap) {
      function deep(i2) {
        var pi = HeapAsync2.getParentIndexOf(i2);
        return Math.floor(Math.log2(pi + 1));
      }
      function repeat(str, times) {
        var out = "";
        for (; times > 0; --times) {
          out += str;
        }
        return out;
      }
      var node = 0;
      var lines = [];
      var maxLines = deep(heap.length - 1) + 2;
      var maxLength = 0;
      while (node < heap.length) {
        var i = deep(node) + 1;
        if (node === 0) {
          i = 0;
        }
        var nodeText = String(heap.get(node));
        if (nodeText.length > maxLength) {
          maxLength = nodeText.length;
        }
        lines[i] = lines[i] || [];
        lines[i].push(nodeText);
        node += 1;
      }
      return lines.map(function(line, i2) {
        var times = Math.pow(2, maxLines - i2) - 1;
        return repeat(" ", Math.floor(times / 2) * maxLength) + line.map(function(el) {
          var half = (maxLength - el.length) / 2;
          return repeat(" ", Math.ceil(half)) + el + repeat(" ", Math.floor(half));
        }).join(repeat(" ", times * maxLength));
      }).join("\n");
    };
    HeapAsync2.heapify = function(arr, compare) {
      return __awaiter(this, void 0, void 0, function() {
        var heap;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              heap = new HeapAsync2(compare);
              heap.heapArray = arr;
              return [4, heap.init()];
            case 1:
              _a.sent();
              return [2, heap];
          }
        });
      });
    };
    HeapAsync2.heappop = function(heapArr, compare) {
      var heap = new HeapAsync2(compare);
      heap.heapArray = heapArr;
      return heap.pop();
    };
    HeapAsync2.heappush = function(heapArr, item, compare) {
      return __awaiter(this, void 0, void 0, function() {
        var heap;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              heap = new HeapAsync2(compare);
              heap.heapArray = heapArr;
              return [4, heap.push(item)];
            case 1:
              _a.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HeapAsync2.heappushpop = function(heapArr, item, compare) {
      var heap = new HeapAsync2(compare);
      heap.heapArray = heapArr;
      return heap.pushpop(item);
    };
    HeapAsync2.heapreplace = function(heapArr, item, compare) {
      var heap = new HeapAsync2(compare);
      heap.heapArray = heapArr;
      return heap.replace(item);
    };
    HeapAsync2.heaptop = function(heapArr, n, compare) {
      if (n === void 0) {
        n = 1;
      }
      var heap = new HeapAsync2(compare);
      heap.heapArray = heapArr;
      return heap.top(n);
    };
    HeapAsync2.heapbottom = function(heapArr, n, compare) {
      if (n === void 0) {
        n = 1;
      }
      var heap = new HeapAsync2(compare);
      heap.heapArray = heapArr;
      return heap.bottom(n);
    };
    HeapAsync2.nlargest = function(n, iterable, compare) {
      return __awaiter(this, void 0, void 0, function() {
        var heap;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              heap = new HeapAsync2(compare);
              heap.heapArray = __spreadArray$1([], __read$1(iterable), false);
              return [4, heap.init()];
            case 1:
              _a.sent();
              return [2, heap.top(n)];
          }
        });
      });
    };
    HeapAsync2.nsmallest = function(n, iterable, compare) {
      return __awaiter(this, void 0, void 0, function() {
        var heap;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              heap = new HeapAsync2(compare);
              heap.heapArray = __spreadArray$1([], __read$1(iterable), false);
              return [4, heap.init()];
            case 1:
              _a.sent();
              return [2, heap.bottom(n)];
          }
        });
      });
    };
    HeapAsync2.prototype.add = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, this._sortNodeUp(this.heapArray.push(element) - 1)];
            case 1:
              _a.sent();
              this._applyLimit();
              return [2, true];
          }
        });
      });
    };
    HeapAsync2.prototype.addAll = function(elements) {
      return __awaiter(this, void 0, void 0, function() {
        var i, l;
        var _a;
        return __generator$1(this, function(_b) {
          switch (_b.label) {
            case 0:
              i = this.length;
              (_a = this.heapArray).push.apply(_a, __spreadArray$1([], __read$1(elements), false));
              l = this.length;
              _b.label = 1;
            case 1:
              if (!(i < l)) return [3, 4];
              return [4, this._sortNodeUp(i)];
            case 2:
              _b.sent();
              _b.label = 3;
            case 3:
              ++i;
              return [3, 1];
            case 4:
              this._applyLimit();
              return [2, true];
          }
        });
      });
    };
    HeapAsync2.prototype.bottom = function(n) {
      if (n === void 0) {
        n = 1;
      }
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          if (this.heapArray.length === 0 || n <= 0) {
            return [2, []];
          } else if (this.heapArray.length === 1) {
            return [2, [this.heapArray[0]]];
          } else if (n >= this.heapArray.length) {
            return [2, __spreadArray$1([], __read$1(this.heapArray), false)];
          } else {
            return [2, this._bottomN_push(~~n)];
          }
        });
      });
    };
    HeapAsync2.prototype.check = function() {
      return __awaiter(this, void 0, void 0, function() {
        var j, el, children, children_1, children_1_1, ch, e_1_1;
        var e_1, _a;
        return __generator$1(this, function(_b) {
          switch (_b.label) {
            case 0:
              j = 0;
              _b.label = 1;
            case 1:
              if (!(j < this.heapArray.length)) return [3, 10];
              el = this.heapArray[j];
              children = this.getChildrenOf(j);
              _b.label = 2;
            case 2:
              _b.trys.push([2, 7, 8, 9]);
              children_1 = (e_1 = void 0, __values(children)), children_1_1 = children_1.next();
              _b.label = 3;
            case 3:
              if (!!children_1_1.done) return [3, 6];
              ch = children_1_1.value;
              return [4, this.compare(el, ch)];
            case 4:
              if (_b.sent() > 0) {
                return [2, el];
              }
              _b.label = 5;
            case 5:
              children_1_1 = children_1.next();
              return [3, 3];
            case 6:
              return [3, 9];
            case 7:
              e_1_1 = _b.sent();
              e_1 = { error: e_1_1 };
              return [3, 9];
            case 8:
              try {
                if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
              } finally {
                if (e_1) throw e_1.error;
              }
              return [
                7
                /*endfinally*/
              ];
            case 9:
              ++j;
              return [3, 1];
            case 10:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HeapAsync2.prototype.clear = function() {
      this.heapArray = [];
    };
    HeapAsync2.prototype.clone = function() {
      var cloned = new HeapAsync2(this.comparator());
      cloned.heapArray = this.toArray();
      cloned._limit = this._limit;
      return cloned;
    };
    HeapAsync2.prototype.comparator = function() {
      return this.compare;
    };
    HeapAsync2.prototype.contains = function(o, fn) {
      if (fn === void 0) {
        fn = HeapAsync2.defaultIsEqual;
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a, _b, el, e_2_1;
        var e_2, _c;
        return __generator$1(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 5, 6, 7]);
              _a = __values(this.heapArray), _b = _a.next();
              _d.label = 1;
            case 1:
              if (!!_b.done) return [3, 4];
              el = _b.value;
              return [4, fn(el, o)];
            case 2:
              if (_d.sent()) {
                return [2, true];
              }
              _d.label = 3;
            case 3:
              _b = _a.next();
              return [3, 1];
            case 4:
              return [3, 7];
            case 5:
              e_2_1 = _d.sent();
              e_2 = { error: e_2_1 };
              return [3, 7];
            case 6:
              try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
              } finally {
                if (e_2) throw e_2.error;
              }
              return [
                7
                /*endfinally*/
              ];
            case 7:
              return [2, false];
          }
        });
      });
    };
    HeapAsync2.prototype.init = function(array) {
      return __awaiter(this, void 0, void 0, function() {
        var i;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (array) {
                this.heapArray = __spreadArray$1([], __read$1(array), false);
              }
              i = Math.floor(this.heapArray.length);
              _a.label = 1;
            case 1:
              if (!(i >= 0)) return [3, 4];
              return [4, this._sortNodeDown(i)];
            case 2:
              _a.sent();
              _a.label = 3;
            case 3:
              --i;
              return [3, 1];
            case 4:
              this._applyLimit();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HeapAsync2.prototype.isEmpty = function() {
      return this.length === 0;
    };
    HeapAsync2.prototype.leafs = function() {
      if (this.heapArray.length === 0) {
        return [];
      }
      var pi = HeapAsync2.getParentIndexOf(this.heapArray.length - 1);
      return this.heapArray.slice(pi + 1);
    };
    Object.defineProperty(HeapAsync2.prototype, "length", {
      /**
       * Length of the heap.
       * @return {Number}
       */
      get: function() {
        return this.heapArray.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HeapAsync2.prototype, "limit", {
      /**
       * Get length limit of the heap.
       * @return {Number}
       */
      get: function() {
        return this._limit;
      },
      /**
       * Set length limit of the heap.
       * @return {Number}
       */
      set: function(_l) {
        this._limit = ~~_l;
        this._applyLimit();
      },
      enumerable: false,
      configurable: true
    });
    HeapAsync2.prototype.peek = function() {
      return this.heapArray[0];
    };
    HeapAsync2.prototype.pop = function() {
      return __awaiter(this, void 0, void 0, function() {
        var last;
        return __generator$1(this, function(_a) {
          last = this.heapArray.pop();
          if (this.length > 0 && last !== void 0) {
            return [2, this.replace(last)];
          }
          return [2, last];
        });
      });
    };
    HeapAsync2.prototype.push = function() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
      }
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          if (elements.length < 1) {
            return [2, false];
          } else if (elements.length === 1) {
            return [2, this.add(elements[0])];
          } else {
            return [2, this.addAll(elements)];
          }
        });
      });
    };
    HeapAsync2.prototype.pushpop = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var _a;
        return __generator$1(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, this.compare(this.heapArray[0], element)];
            case 1:
              if (!(_b.sent() < 0)) return [3, 3];
              _a = __read$1([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];
              return [4, this._sortNodeDown(0)];
            case 2:
              _b.sent();
              _b.label = 3;
            case 3:
              return [2, element];
          }
        });
      });
    };
    HeapAsync2.prototype.remove = function(o, fn) {
      if (fn === void 0) {
        fn = HeapAsync2.defaultIsEqual;
      }
      return __awaiter(this, void 0, void 0, function() {
        var idx, i;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!(this.length > 0)) return [3, 13];
              if (!(o === void 0)) return [3, 2];
              return [4, this.pop()];
            case 1:
              _a.sent();
              return [2, true];
            case 2:
              idx = -1;
              i = 0;
              _a.label = 3;
            case 3:
              if (!(i < this.heapArray.length)) return [3, 6];
              return [4, fn(this.heapArray[i], o)];
            case 4:
              if (_a.sent()) {
                idx = i;
                return [3, 6];
              }
              _a.label = 5;
            case 5:
              ++i;
              return [3, 3];
            case 6:
              if (!(idx >= 0)) return [3, 13];
              if (!(idx === 0)) return [3, 8];
              return [4, this.pop()];
            case 7:
              _a.sent();
              return [3, 12];
            case 8:
              if (!(idx === this.length - 1)) return [3, 9];
              this.heapArray.pop();
              return [3, 12];
            case 9:
              this.heapArray.splice(idx, 1, this.heapArray.pop());
              return [4, this._sortNodeUp(idx)];
            case 10:
              _a.sent();
              return [4, this._sortNodeDown(idx)];
            case 11:
              _a.sent();
              _a.label = 12;
            case 12:
              return [2, true];
            case 13:
              return [2, false];
          }
        });
      });
    };
    HeapAsync2.prototype.replace = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var peek;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              peek = this.heapArray[0];
              this.heapArray[0] = element;
              return [4, this._sortNodeDown(0)];
            case 1:
              _a.sent();
              return [2, peek];
          }
        });
      });
    };
    HeapAsync2.prototype.size = function() {
      return this.length;
    };
    HeapAsync2.prototype.top = function(n) {
      if (n === void 0) {
        n = 1;
      }
      return __awaiter(this, void 0, void 0, function() {
        return __generator$1(this, function(_a) {
          if (this.heapArray.length === 0 || n <= 0) {
            return [2, []];
          } else if (this.heapArray.length === 1 || n === 1) {
            return [2, [this.heapArray[0]]];
          } else if (n >= this.heapArray.length) {
            return [2, __spreadArray$1([], __read$1(this.heapArray), false)];
          } else {
            return [2, this._topN_push(~~n)];
          }
        });
      });
    };
    HeapAsync2.prototype.toArray = function() {
      return __spreadArray$1([], __read$1(this.heapArray), false);
    };
    HeapAsync2.prototype.toString = function() {
      return this.heapArray.toString();
    };
    HeapAsync2.prototype.get = function(i) {
      return this.heapArray[i];
    };
    HeapAsync2.prototype.getChildrenOf = function(idx) {
      var _this = this;
      return HeapAsync2.getChildrenIndexOf(idx).map(function(i) {
        return _this.heapArray[i];
      }).filter(function(e) {
        return e !== void 0;
      });
    };
    HeapAsync2.prototype.getParentOf = function(idx) {
      var pi = HeapAsync2.getParentIndexOf(idx);
      return this.heapArray[pi];
    };
    HeapAsync2.prototype[Symbol.iterator] = function() {
      return __generator$1(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this.length) return [3, 2];
            return [4, this.pop()];
          case 1:
            _a.sent();
            return [3, 0];
          case 2:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    HeapAsync2.prototype.iterator = function() {
      return this;
    };
    HeapAsync2.prototype._applyLimit = function() {
      if (this._limit && this._limit < this.heapArray.length) {
        var rm = this.heapArray.length - this._limit;
        while (rm) {
          this.heapArray.pop();
          --rm;
        }
      }
    };
    HeapAsync2.prototype._bottomN_push = function(n) {
      return __awaiter(this, void 0, void 0, function() {
        var bottomHeap, startAt, parentStartAt, indices, i, arr, i;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              bottomHeap = new HeapAsync2(this.compare);
              bottomHeap.limit = n;
              bottomHeap.heapArray = this.heapArray.slice(-n);
              return [4, bottomHeap.init()];
            case 1:
              _a.sent();
              startAt = this.heapArray.length - 1 - n;
              parentStartAt = HeapAsync2.getParentIndexOf(startAt);
              indices = [];
              for (i = startAt; i > parentStartAt; --i) {
                indices.push(i);
              }
              arr = this.heapArray;
              _a.label = 2;
            case 2:
              if (!indices.length) return [3, 6];
              i = indices.shift();
              return [4, this.compare(arr[i], bottomHeap.peek())];
            case 3:
              if (!(_a.sent() > 0)) return [3, 5];
              return [4, bottomHeap.replace(arr[i])];
            case 4:
              _a.sent();
              if (i % 2) {
                indices.push(HeapAsync2.getParentIndexOf(i));
              }
              _a.label = 5;
            case 5:
              return [3, 2];
            case 6:
              return [2, bottomHeap.toArray()];
          }
        });
      });
    };
    HeapAsync2.prototype._moveNode = function(j, k) {
      var _a;
      _a = __read$1([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];
    };
    HeapAsync2.prototype._sortNodeDown = function(i) {
      return __awaiter(this, void 0, void 0, function() {
        var moveIt, self, getPotentialParent, childrenIdx, bestChildIndex, j, bestChild, _a;
        var _this = this;
        return __generator$1(this, function(_b) {
          switch (_b.label) {
            case 0:
              moveIt = i < this.heapArray.length - 1;
              self = this.heapArray[i];
              getPotentialParent = function(best, j2) {
                return __awaiter(_this, void 0, void 0, function() {
                  var _a2;
                  return __generator$1(this, function(_b2) {
                    switch (_b2.label) {
                      case 0:
                        _a2 = this.heapArray.length > j2;
                        if (!_a2) return [3, 2];
                        return [4, this.compare(this.heapArray[j2], this.heapArray[best])];
                      case 1:
                        _a2 = _b2.sent() < 0;
                        _b2.label = 2;
                      case 2:
                        if (_a2) {
                          best = j2;
                        }
                        return [2, best];
                    }
                  });
                });
              };
              _b.label = 1;
            case 1:
              if (!moveIt) return [3, 8];
              childrenIdx = HeapAsync2.getChildrenIndexOf(i);
              bestChildIndex = childrenIdx[0];
              j = 1;
              _b.label = 2;
            case 2:
              if (!(j < childrenIdx.length)) return [3, 5];
              return [4, getPotentialParent(bestChildIndex, childrenIdx[j])];
            case 3:
              bestChildIndex = _b.sent();
              _b.label = 4;
            case 4:
              ++j;
              return [3, 2];
            case 5:
              bestChild = this.heapArray[bestChildIndex];
              _a = typeof bestChild !== "undefined";
              if (!_a) return [3, 7];
              return [4, this.compare(self, bestChild)];
            case 6:
              _a = _b.sent() > 0;
              _b.label = 7;
            case 7:
              if (_a) {
                this._moveNode(i, bestChildIndex);
                i = bestChildIndex;
              } else {
                moveIt = false;
              }
              return [3, 1];
            case 8:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HeapAsync2.prototype._sortNodeUp = function(i) {
      return __awaiter(this, void 0, void 0, function() {
        var moveIt, pi, _a;
        return __generator$1(this, function(_b) {
          switch (_b.label) {
            case 0:
              moveIt = i > 0;
              _b.label = 1;
            case 1:
              if (!moveIt) return [3, 4];
              pi = HeapAsync2.getParentIndexOf(i);
              _a = pi >= 0;
              if (!_a) return [3, 3];
              return [4, this.compare(this.heapArray[pi], this.heapArray[i])];
            case 2:
              _a = _b.sent() > 0;
              _b.label = 3;
            case 3:
              if (_a) {
                this._moveNode(i, pi);
                i = pi;
              } else {
                moveIt = false;
              }
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HeapAsync2.prototype._topN_push = function(n) {
      return __awaiter(this, void 0, void 0, function() {
        var topHeap, indices, arr, i;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              topHeap = new HeapAsync2(this._invertedCompare);
              topHeap.limit = n;
              indices = [0];
              arr = this.heapArray;
              _a.label = 1;
            case 1:
              if (!indices.length) return [3, 7];
              i = indices.shift();
              if (!(i < arr.length)) return [3, 6];
              if (!(topHeap.length < n)) return [3, 3];
              return [4, topHeap.push(arr[i])];
            case 2:
              _a.sent();
              indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync2.getChildrenIndexOf(i)), false));
              return [3, 6];
            case 3:
              return [4, this.compare(arr[i], topHeap.peek())];
            case 4:
              if (!(_a.sent() < 0)) return [3, 6];
              return [4, topHeap.replace(arr[i])];
            case 5:
              _a.sent();
              indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync2.getChildrenIndexOf(i)), false));
              _a.label = 6;
            case 6:
              return [3, 1];
            case 7:
              return [2, topHeap.toArray()];
          }
        });
      });
    };
    HeapAsync2.prototype._topN_fill = function(n) {
      return __awaiter(this, void 0, void 0, function() {
        var heapArray, topHeap, branch, indices, i, i;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              heapArray = this.heapArray;
              topHeap = new HeapAsync2(this._invertedCompare);
              topHeap.limit = n;
              topHeap.heapArray = heapArray.slice(0, n);
              return [4, topHeap.init()];
            case 1:
              _a.sent();
              branch = HeapAsync2.getParentIndexOf(n - 1) + 1;
              indices = [];
              for (i = branch; i < n; ++i) {
                indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync2.getChildrenIndexOf(i).filter(function(l) {
                  return l < heapArray.length;
                })), false));
              }
              if ((n - 1) % 2) {
                indices.push(n);
              }
              _a.label = 2;
            case 2:
              if (!indices.length) return [3, 6];
              i = indices.shift();
              if (!(i < heapArray.length)) return [3, 5];
              return [4, this.compare(heapArray[i], topHeap.peek())];
            case 3:
              if (!(_a.sent() < 0)) return [3, 5];
              return [4, topHeap.replace(heapArray[i])];
            case 4:
              _a.sent();
              indices.push.apply(indices, __spreadArray$1([], __read$1(HeapAsync2.getChildrenIndexOf(i)), false));
              _a.label = 5;
            case 5:
              return [3, 2];
            case 6:
              return [2, topHeap.toArray()];
          }
        });
      });
    };
    HeapAsync2.prototype._topN_heap = function(n) {
      return __awaiter(this, void 0, void 0, function() {
        var topHeap, result, i, _a, _b;
        return __generator$1(this, function(_c) {
          switch (_c.label) {
            case 0:
              topHeap = this.clone();
              result = [];
              i = 0;
              _c.label = 1;
            case 1:
              if (!(i < n)) return [3, 4];
              _b = (_a = result).push;
              return [4, topHeap.pop()];
            case 2:
              _b.apply(_a, [_c.sent()]);
              _c.label = 3;
            case 3:
              ++i;
              return [3, 1];
            case 4:
              return [2, result];
          }
        });
      });
    };
    HeapAsync2.prototype._topIdxOf = function(list) {
      return __awaiter(this, void 0, void 0, function() {
        var idx, top, i, comp;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!list.length) {
                return [2, -1];
              }
              idx = 0;
              top = list[idx];
              i = 1;
              _a.label = 1;
            case 1:
              if (!(i < list.length)) return [3, 4];
              return [4, this.compare(list[i], top)];
            case 2:
              comp = _a.sent();
              if (comp < 0) {
                idx = i;
                top = list[i];
              }
              _a.label = 3;
            case 3:
              ++i;
              return [3, 1];
            case 4:
              return [2, idx];
          }
        });
      });
    };
    HeapAsync2.prototype._topOf = function() {
      var list = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        list[_i] = arguments[_i];
      }
      return __awaiter(this, void 0, void 0, function() {
        var heap;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              heap = new HeapAsync2(this.compare);
              return [4, heap.init(list)];
            case 1:
              _a.sent();
              return [2, heap.peek()];
          }
        });
      });
    };
    return HeapAsync2;
  }()
);
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var toInt = function(n) {
  return ~~n;
};
var Heap = (
  /** @class */
  function() {
    function Heap2(compare) {
      if (compare === void 0) {
        compare = Heap2.minComparator;
      }
      var _this = this;
      this.compare = compare;
      this.heapArray = [];
      this._limit = 0;
      this.offer = this.add;
      this.element = this.peek;
      this.poll = this.pop;
      this.removeAll = this.clear;
      this._invertedCompare = function(a, b) {
        return -1 * _this.compare(a, b);
      };
    }
    Heap2.getChildrenIndexOf = function(idx) {
      return [idx * 2 + 1, idx * 2 + 2];
    };
    Heap2.getParentIndexOf = function(idx) {
      if (idx <= 0) {
        return -1;
      }
      var whichChildren = idx % 2 ? 1 : 2;
      return Math.floor((idx - whichChildren) / 2);
    };
    Heap2.getSiblingIndexOf = function(idx) {
      if (idx <= 0) {
        return -1;
      }
      var whichChildren = idx % 2 ? 1 : -1;
      return idx + whichChildren;
    };
    Heap2.minComparator = function(a, b) {
      if (a > b) {
        return 1;
      } else if (a < b) {
        return -1;
      } else {
        return 0;
      }
    };
    Heap2.maxComparator = function(a, b) {
      if (b > a) {
        return 1;
      } else if (b < a) {
        return -1;
      } else {
        return 0;
      }
    };
    Heap2.minComparatorNumber = function(a, b) {
      return a - b;
    };
    Heap2.maxComparatorNumber = function(a, b) {
      return b - a;
    };
    Heap2.defaultIsEqual = function(a, b) {
      return a === b;
    };
    Heap2.print = function(heap) {
      function deep(i2) {
        var pi = Heap2.getParentIndexOf(i2);
        return Math.floor(Math.log2(pi + 1));
      }
      function repeat(str, times) {
        var out = "";
        for (; times > 0; --times) {
          out += str;
        }
        return out;
      }
      var node = 0;
      var lines = [];
      var maxLines = deep(heap.length - 1) + 2;
      var maxLength = 0;
      while (node < heap.length) {
        var i = deep(node) + 1;
        if (node === 0) {
          i = 0;
        }
        var nodeText = String(heap.get(node));
        if (nodeText.length > maxLength) {
          maxLength = nodeText.length;
        }
        lines[i] = lines[i] || [];
        lines[i].push(nodeText);
        node += 1;
      }
      return lines.map(function(line, i2) {
        var times = Math.pow(2, maxLines - i2) - 1;
        return repeat(" ", Math.floor(times / 2) * maxLength) + line.map(function(el) {
          var half = (maxLength - el.length) / 2;
          return repeat(" ", Math.ceil(half)) + el + repeat(" ", Math.floor(half));
        }).join(repeat(" ", times * maxLength));
      }).join("\n");
    };
    Heap2.heapify = function(arr, compare) {
      var heap = new Heap2(compare);
      heap.heapArray = arr;
      heap.init();
      return heap;
    };
    Heap2.heappop = function(heapArr, compare) {
      var heap = new Heap2(compare);
      heap.heapArray = heapArr;
      return heap.pop();
    };
    Heap2.heappush = function(heapArr, item, compare) {
      var heap = new Heap2(compare);
      heap.heapArray = heapArr;
      heap.push(item);
    };
    Heap2.heappushpop = function(heapArr, item, compare) {
      var heap = new Heap2(compare);
      heap.heapArray = heapArr;
      return heap.pushpop(item);
    };
    Heap2.heapreplace = function(heapArr, item, compare) {
      var heap = new Heap2(compare);
      heap.heapArray = heapArr;
      return heap.replace(item);
    };
    Heap2.heaptop = function(heapArr, n, compare) {
      if (n === void 0) {
        n = 1;
      }
      var heap = new Heap2(compare);
      heap.heapArray = heapArr;
      return heap.top(n);
    };
    Heap2.heapbottom = function(heapArr, n, compare) {
      if (n === void 0) {
        n = 1;
      }
      var heap = new Heap2(compare);
      heap.heapArray = heapArr;
      return heap.bottom(n);
    };
    Heap2.nlargest = function(n, iterable, compare) {
      var heap = new Heap2(compare);
      heap.heapArray = __spreadArray([], __read(iterable), false);
      heap.init();
      return heap.top(n);
    };
    Heap2.nsmallest = function(n, iterable, compare) {
      var heap = new Heap2(compare);
      heap.heapArray = __spreadArray([], __read(iterable), false);
      heap.init();
      return heap.bottom(n);
    };
    Heap2.prototype.add = function(element) {
      this._sortNodeUp(this.heapArray.push(element) - 1);
      this._applyLimit();
      return true;
    };
    Heap2.prototype.addAll = function(elements) {
      var _a;
      var i = this.length;
      (_a = this.heapArray).push.apply(_a, __spreadArray([], __read(elements), false));
      for (var l = this.length; i < l; ++i) {
        this._sortNodeUp(i);
      }
      this._applyLimit();
      return true;
    };
    Heap2.prototype.bottom = function(n) {
      if (n === void 0) {
        n = 1;
      }
      if (this.heapArray.length === 0 || n <= 0) {
        return [];
      } else if (this.heapArray.length === 1) {
        return [this.heapArray[0]];
      } else if (n >= this.heapArray.length) {
        return __spreadArray([], __read(this.heapArray), false);
      } else {
        return this._bottomN_push(~~n);
      }
    };
    Heap2.prototype.check = function() {
      var _this = this;
      return this.heapArray.find(function(el, j) {
        return !!_this.getChildrenOf(j).find(function(ch) {
          return _this.compare(el, ch) > 0;
        });
      });
    };
    Heap2.prototype.clear = function() {
      this.heapArray = [];
    };
    Heap2.prototype.clone = function() {
      var cloned = new Heap2(this.comparator());
      cloned.heapArray = this.toArray();
      cloned._limit = this._limit;
      return cloned;
    };
    Heap2.prototype.comparator = function() {
      return this.compare;
    };
    Heap2.prototype.contains = function(o, callbackFn) {
      if (callbackFn === void 0) {
        callbackFn = Heap2.defaultIsEqual;
      }
      return this.indexOf(o, callbackFn) !== -1;
    };
    Heap2.prototype.init = function(array) {
      if (array) {
        this.heapArray = __spreadArray([], __read(array), false);
      }
      for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {
        this._sortNodeDown(i);
      }
      this._applyLimit();
    };
    Heap2.prototype.isEmpty = function() {
      return this.length === 0;
    };
    Heap2.prototype.indexOf = function(element, callbackFn) {
      if (callbackFn === void 0) {
        callbackFn = Heap2.defaultIsEqual;
      }
      if (this.heapArray.length === 0) {
        return -1;
      }
      var indexes = [];
      var currentIndex = 0;
      while (currentIndex < this.heapArray.length) {
        var currentElement = this.heapArray[currentIndex];
        if (callbackFn(currentElement, element)) {
          return currentIndex;
        } else if (this.compare(currentElement, element) <= 0) {
          indexes.push.apply(indexes, __spreadArray([], __read(Heap2.getChildrenIndexOf(currentIndex)), false));
        }
        currentIndex = indexes.shift() || this.heapArray.length;
      }
      return -1;
    };
    Heap2.prototype.indexOfEvery = function(element, callbackFn) {
      if (callbackFn === void 0) {
        callbackFn = Heap2.defaultIsEqual;
      }
      if (this.heapArray.length === 0) {
        return [];
      }
      var indexes = [];
      var foundIndexes = [];
      var currentIndex = 0;
      while (currentIndex < this.heapArray.length) {
        var currentElement = this.heapArray[currentIndex];
        if (callbackFn(currentElement, element)) {
          foundIndexes.push(currentIndex);
          indexes.push.apply(indexes, __spreadArray([], __read(Heap2.getChildrenIndexOf(currentIndex)), false));
        } else if (this.compare(currentElement, element) <= 0) {
          indexes.push.apply(indexes, __spreadArray([], __read(Heap2.getChildrenIndexOf(currentIndex)), false));
        }
        currentIndex = indexes.shift() || this.heapArray.length;
      }
      return foundIndexes;
    };
    Heap2.prototype.leafs = function() {
      if (this.heapArray.length === 0) {
        return [];
      }
      var pi = Heap2.getParentIndexOf(this.heapArray.length - 1);
      return this.heapArray.slice(pi + 1);
    };
    Object.defineProperty(Heap2.prototype, "length", {
      /**
       * Length of the heap. Aliases: {@link size}.
       * @return {Number}
       * @see size
       */
      get: function() {
        return this.heapArray.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Heap2.prototype, "limit", {
      /**
       * Get length limit of the heap.
       * Use {@link setLimit} or {@link limit} to set the limit.
       * @return {Number}
       * @see setLimit
       */
      get: function() {
        return this._limit;
      },
      /**
       * Set length limit of the heap. Same as using {@link setLimit}.
       * @description If the heap is longer than the limit, the needed amount of leafs are removed.
       * @param {Number} _l Limit, defaults to 0 (no limit). Negative, Infinity, or NaN values set the limit to 0.
       * @see setLimit
       */
      set: function(_l) {
        if (_l < 0 || isNaN(_l)) {
          this._limit = 0;
        } else {
          this._limit = ~~_l;
        }
        this._applyLimit();
      },
      enumerable: false,
      configurable: true
    });
    Heap2.prototype.setLimit = function(_l) {
      this.limit = _l;
      if (_l < 0 || isNaN(_l)) {
        return NaN;
      } else {
        return this._limit;
      }
    };
    Heap2.prototype.peek = function() {
      return this.heapArray[0];
    };
    Heap2.prototype.pop = function() {
      var last = this.heapArray.pop();
      if (this.length > 0 && last !== void 0) {
        return this.replace(last);
      }
      return last;
    };
    Heap2.prototype.push = function() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
      }
      if (elements.length < 1) {
        return false;
      } else if (elements.length === 1) {
        return this.add(elements[0]);
      } else {
        return this.addAll(elements);
      }
    };
    Heap2.prototype.pushpop = function(element) {
      var _a;
      if (this.compare(this.heapArray[0], element) < 0) {
        _a = __read([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];
        this._sortNodeDown(0);
      }
      return element;
    };
    Heap2.prototype.remove = function(o, callbackFn) {
      if (callbackFn === void 0) {
        callbackFn = Heap2.defaultIsEqual;
      }
      if (this.length > 0) {
        if (o === void 0) {
          this.pop();
          return true;
        } else {
          var idx = this.indexOf(o, callbackFn);
          if (idx >= 0) {
            if (idx === 0) {
              this.pop();
            } else if (idx === this.length - 1) {
              this.heapArray.pop();
            } else {
              this.heapArray.splice(idx, 1, this.heapArray.pop());
              this._sortNodeUp(idx);
              this._sortNodeDown(idx);
            }
            return true;
          }
        }
      }
      return false;
    };
    Heap2.prototype.replace = function(element) {
      var peek = this.heapArray[0];
      this.heapArray[0] = element;
      this._sortNodeDown(0);
      return peek;
    };
    Heap2.prototype.size = function() {
      return this.length;
    };
    Heap2.prototype.top = function(n) {
      if (n === void 0) {
        n = 1;
      }
      if (this.heapArray.length === 0 || n <= 0) {
        return [];
      } else if (this.heapArray.length === 1 || n === 1) {
        return [this.heapArray[0]];
      } else if (n >= this.heapArray.length) {
        return __spreadArray([], __read(this.heapArray), false);
      } else {
        return this._topN_push(~~n);
      }
    };
    Heap2.prototype.toArray = function() {
      return __spreadArray([], __read(this.heapArray), false);
    };
    Heap2.prototype.toString = function() {
      return this.heapArray.toString();
    };
    Heap2.prototype.get = function(i) {
      return this.heapArray[i];
    };
    Heap2.prototype.getChildrenOf = function(idx) {
      var _this = this;
      return Heap2.getChildrenIndexOf(idx).map(function(i) {
        return _this.heapArray[i];
      }).filter(function(e) {
        return e !== void 0;
      });
    };
    Heap2.prototype.getParentOf = function(idx) {
      var pi = Heap2.getParentIndexOf(idx);
      return this.heapArray[pi];
    };
    Heap2.prototype[Symbol.iterator] = function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this.length) return [3, 2];
            return [4, this.pop()];
          case 1:
            _a.sent();
            return [3, 0];
          case 2:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    Heap2.prototype.iterator = function() {
      return this.toArray();
    };
    Heap2.prototype._applyLimit = function() {
      if (this._limit > 0 && this._limit < this.heapArray.length) {
        var rm = this.heapArray.length - this._limit;
        while (rm) {
          this.heapArray.pop();
          --rm;
        }
      }
    };
    Heap2.prototype._bottomN_push = function(n) {
      var bottomHeap = new Heap2(this.compare);
      bottomHeap.limit = n;
      bottomHeap.heapArray = this.heapArray.slice(-n);
      bottomHeap.init();
      var startAt = this.heapArray.length - 1 - n;
      var parentStartAt = Heap2.getParentIndexOf(startAt);
      var indices = [];
      for (var i = startAt; i > parentStartAt; --i) {
        indices.push(i);
      }
      var arr = this.heapArray;
      while (indices.length) {
        var i = indices.shift();
        if (this.compare(arr[i], bottomHeap.peek()) > 0) {
          bottomHeap.replace(arr[i]);
          if (i % 2) {
            indices.push(Heap2.getParentIndexOf(i));
          }
        }
      }
      return bottomHeap.toArray();
    };
    Heap2.prototype._moveNode = function(j, k) {
      var _a;
      _a = __read([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];
    };
    Heap2.prototype._sortNodeDown = function(i) {
      var _this = this;
      var moveIt = i < this.heapArray.length - 1;
      var self = this.heapArray[i];
      var getPotentialParent = function(best, j) {
        if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {
          best = j;
        }
        return best;
      };
      while (moveIt) {
        var childrenIdx = Heap2.getChildrenIndexOf(i);
        var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);
        var bestChild = this.heapArray[bestChildIndex];
        if (typeof bestChild !== "undefined" && this.compare(self, bestChild) > 0) {
          this._moveNode(i, bestChildIndex);
          i = bestChildIndex;
        } else {
          moveIt = false;
        }
      }
    };
    Heap2.prototype._sortNodeUp = function(i) {
      var moveIt = i > 0;
      while (moveIt) {
        var pi = Heap2.getParentIndexOf(i);
        if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {
          this._moveNode(i, pi);
          i = pi;
        } else {
          moveIt = false;
        }
      }
    };
    Heap2.prototype._topN_push = function(n) {
      var topHeap = new Heap2(this._invertedCompare);
      topHeap.limit = n;
      var indices = [0];
      var arr = this.heapArray;
      while (indices.length) {
        var i = indices.shift();
        if (i < arr.length) {
          if (topHeap.length < n) {
            topHeap.push(arr[i]);
            indices.push.apply(indices, __spreadArray([], __read(Heap2.getChildrenIndexOf(i)), false));
          } else if (this.compare(arr[i], topHeap.peek()) < 0) {
            topHeap.replace(arr[i]);
            indices.push.apply(indices, __spreadArray([], __read(Heap2.getChildrenIndexOf(i)), false));
          }
        }
      }
      return topHeap.toArray();
    };
    Heap2.prototype._topN_fill = function(n) {
      var heapArray = this.heapArray;
      var topHeap = new Heap2(this._invertedCompare);
      topHeap.limit = n;
      topHeap.heapArray = heapArray.slice(0, n);
      topHeap.init();
      var branch = Heap2.getParentIndexOf(n - 1) + 1;
      var indices = [];
      for (var i = branch; i < n; ++i) {
        indices.push.apply(indices, __spreadArray([], __read(Heap2.getChildrenIndexOf(i).filter(function(l) {
          return l < heapArray.length;
        })), false));
      }
      if ((n - 1) % 2) {
        indices.push(n);
      }
      while (indices.length) {
        var i = indices.shift();
        if (i < heapArray.length) {
          if (this.compare(heapArray[i], topHeap.peek()) < 0) {
            topHeap.replace(heapArray[i]);
            indices.push.apply(indices, __spreadArray([], __read(Heap2.getChildrenIndexOf(i)), false));
          }
        }
      }
      return topHeap.toArray();
    };
    Heap2.prototype._topN_heap = function(n) {
      var topHeap = this.clone();
      var result = [];
      for (var i = 0; i < n; ++i) {
        result.push(topHeap.pop());
      }
      return result;
    };
    Heap2.prototype._topIdxOf = function(list) {
      if (!list.length) {
        return -1;
      }
      var idx = 0;
      var top = list[idx];
      for (var i = 1; i < list.length; ++i) {
        var comp = this.compare(list[i], top);
        if (comp < 0) {
          idx = i;
          top = list[i];
        }
      }
      return idx;
    };
    Heap2.prototype._topOf = function() {
      var list = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        list[_i] = arguments[_i];
      }
      var heap = new Heap2(this.compare);
      heap.init(list);
      return heap.peek();
    };
    return Heap2;
  }()
);
export {
  Heap,
  HeapAsync,
  Heap as default,
  toInt
};
//# sourceMappingURL=heap-js.js.map
